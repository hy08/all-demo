# Webpack 进阶篇

## 自动清理构建目录

每次构建会自动清除构建目录，省得手动清理。

```js
//webpack.prod.js
const { CleanWebpackPlugin } = require('clean-webpack-plugin'); //安装依赖version: ^4.0.0
module.exports = {
  plugins: [new CleanWebpackPlugin()],
};
```

## PostCSS 插件 autoprefixer 自动补齐 CSS3 前缀

为了兼容不同的渲染内核，需要使用 css 属性的自动补齐前缀功能。
PostCSS 后置处理，即 css 样式已经生成之后进行样式补齐。
原理：根据 can-i-use 规则生成

```js
//webpack.prod.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader',
          {
            loader: 'postcss-loader', //安装依赖
            options: {
              postcssOptions: {
                plugins: [
                  //安装依赖
                  require('autoprefixer')({
                    //兼容最新的两个版本，>1%使用的浏览器，兼容>=IOS 7
                    overrideBrowserslist: ['last 2 version', '>1%', 'IOS 7'],
                  }),
                ],
              },
            },
          },
        ],
      },
    ],
  },
};
```

## 移动端 CSS px 自动转换 rem

```js
//webpack.prod.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader',
          {
            loader: 'px2rem-loader', //安装依赖，还需要npm i lib-flexible -S
            options: {
              remUnit: 75, //1rem=75px
              remPrecision: 8, //保留rem小数位数
            },
          },
        ],
      },
    ],
  },
};
```

## 静态资源内联

意义：

1. 页面框架初始化脚本
2. css 内联避免页面山东
3. 上报相关功能点
4. 减少关键资源的请求数（小图片等 url-loader）

### HTML 和 JS 内联

安装依赖 raw-loader（0.5.1 版本）内联 html 和 js

```ejs
<%= require('raw-loader!./meta.html') %>
<script>
  <%= require('raw-loader!babel-loader!../../node_modules/lib-flexible/flexible.js') %>
</script>
```

### CSS 内联

安装 style-loader,将样式插入<head>标签

## 多页面应用打包通用方案

多页应用优势：

1. SEO 优化
2. 页面之间天然解耦

方案：动态获取 entry 和设置 html-webpack-plugin 数量

安装 glob 和 html-webpack-plugin 依赖。

```js
const setMPA = () => {
  const entry = {};
  const htmlWebpackPlugins = [];
  const entryFiles = glob.sync('./src/view/*/index.js');

  entryFiles.forEach((file) => {
    const match = file.match(/src\/view\/(.*)\/index.js/); //获取文件路径
    const pageName = match && match[1];
    entry[pageName] = file;
    htmlWebpackPlugins.push(
      new HtmlPlugin({
        template: path.join(__dirname, `src/view/${pageName}/index.html`),
        filename: `${pageName}.html`,
        chunks: [pageName], //打包的页面使用那些chunk
        inject: true,
        minify: {
          html5: true, // html5压缩
          collapseWhitespace: true,
          preserveLineBreaks: false,
          minifyCSS: true,
          minifyJS: true,
          removeComments: false,
        },
      })
    );
  });
  console.log('entryFiles', entryFiles, entry);
  return { entry, htmlWebpackPlugins };
};

const { entry, htmlWebpackPlugins } = setMPA();
module.exports = {
  entry,
  plugins: [
    //html模板插件
    ...htmlWebpackPlugins,
  ],
};
```

## 使用 sourcemap

作用：通过 sourcemap 定位到源代码行和列
开发环境开启，线上环境关闭（线上排查问题的时候可以将 sourcemap 上传到错误监控系统）

```js
module.exports = {
  devtool: 'source-map',
};
```

## 提取页面公共资源

意义：多页面场景优化打包速度

方案：基础库分离

分离 react、react-dom 等不易变动的基础库以 CDN 方式引入，不计入 bundle 中
安装依赖 SplitChunksPlugin

注：通常可以使用开箱即用的 SplitChunksPlugin 配置，即如果是通过一些脚手架创建的项目，通常不需要主动进行配置

```js
module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        extractComments: false,
      }),
      new CssMinimizerPlugin(),
    ],
    splitChunks: {
      cacheGroups: {
        commons: {
          test: /(react|react-dom)/,
          name: 'vendors', //注意在html-webpack-plugin的实例中需要配置相关chunk。chunks: ['vendors', pageName],
          chunks: 'all',
        },
      },
    },
  },
};
```

## Tree Shaking 的使用和原理分析

production 模式默认开启。

原理：如果一个模块由多个方法，但是只有个别方法使用到，那么会只打包使用到的方法，擦除未使用的代码。

## Scope Hosting 的使用和原理分析

production 模式默认开启。

原理：将所有模块的代码按照引用顺序放在一个函数作用域中，适当重命名一些变量防止变量名冲突。可以减少函数声明代码和内存开销。

## 代码分割和动态 import

使用场景：

1. 抽离相同代码
2. 脚本懒加载，使用动态 import。例如首屏渲染

```js
// 1. 安装依赖@babel/plugin-syntax-dynamic-import
// 2. 设置.babelrc
{
  "plugins": ["@babel/plugin-syntax-dynamic-import"]
}
// 3. 使用import语法，Text是一个react组件
const [component, setComponent] = useState(null);
import('./text').then((Text) => {
  setComponent(Text.default);
});
```

## 在 webpack 中使用 ESLint

```js

```

## webpack 打包组件和基础库

```js

```

## webpack 实现 SSR 打包

```js

```

## 优化构建时命令行的显示日志

```js

```

## 构建异常和中断处理

```js

```
